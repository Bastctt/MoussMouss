{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nclass SphereGeometry extends BufferGeometry {\n  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {\n    super();\n    this.type = 'SphereGeometry';\n    this.parameters = {\n      radius: radius,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      phiStart: phiStart,\n      phiLength: phiLength,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    let index = 0;\n    const grid = [];\n    const vertex = new Vector3();\n    const normal = new Vector3();\n\n    // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    // generate vertices, normals and uvs\n\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / heightSegments;\n\n      // special case for the poles\n\n      let uOffset = 0;\n      if (iy === 0 && thetaStart === 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy === heightSegments && thetaEnd === Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n      for (let ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments;\n\n        // vertex\n\n        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n\n        // normal\n\n        normal.copy(vertex).normalize();\n        normals.push(normal.x, normal.y, normal.z);\n\n        // uv\n\n        uvs.push(u + uOffset, 1 - v);\n        verticesRow.push(index++);\n      }\n      grid.push(verticesRow);\n    }\n\n    // indices\n\n    for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < widthSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);\n        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);\n      }\n    }\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);\n  }\n}\nexport { SphereGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Vector3","SphereGeometry","constructor","radius","widthSegments","heightSegments","phiStart","phiLength","Math","PI","thetaStart","thetaLength","type","parameters","max","floor","thetaEnd","min","index","grid","vertex","normal","indices","vertices","normals","uvs","iy","verticesRow","v","uOffset","ix","u","x","cos","sin","y","z","push","copy","normalize","a","b","c","d","setIndex","setAttribute","source","Object","assign","fromJSON","data"],"sources":["/Users/bastien/Desktop/MoussMouss/node_modules/three/src/geometries/SphereGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass SphereGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) );\n\n\t\tconst thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\n\n\t\tlet index = 0;\n\t\tconst grid = [];\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\t\tconst verticesRow = [];\n\n\t\t\tconst v = iy / heightSegments;\n\n\t\t\t// special case for the poles\n\n\t\t\tlet uOffset = 0;\n\n\t\t\tif ( iy === 0 && thetaStart === 0 ) {\n\n\t\t\t\tuOffset = 0.5 / widthSegments;\n\n\t\t\t} else if ( iy === heightSegments && thetaEnd === Math.PI ) {\n\n\t\t\t\tuOffset = - 0.5 / widthSegments;\n\n\t\t\t}\n\n\t\t\tfor ( let ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\t\tconst u = ix / widthSegments;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.copy( vertex ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u + uOffset, 1 - v );\n\n\t\t\t\tverticesRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\tgrid.push( verticesRow );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\t\tconst a = grid[ iy ][ ix + 1 ];\n\t\t\t\tconst b = grid[ iy ][ ix ];\n\t\t\t\tconst c = grid[ iy + 1 ][ ix ];\n\t\t\t\tconst d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nexport { SphereGeometry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}